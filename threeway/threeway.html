<script type="text/html" data-template-name="andrerodrigue5-threeway">
    <style>
        .block_entity > .red-ui-editableList > .red-ui-editableList-border {
            border-radius: 0 0 4px 4px;
        }
    </style>
    <div class="form-row">
        <label for="node-input-name">Name</label>
        <input type="text" id="node-input-name" placeholder="Nome">
    </div>
    <div class="form-row">
        <label for="node-input-server">Server</label>
        <input type="text" id="node-input-server">
    </div>
    <div class="form-row block_entity">
        <label for="node-input-entity-input">Targets</label>
        <div style="display: flex; flex-grow: 1; flex-basis: 0%; position: relative;">
            <label for="node-input-entity-input" style="position: absolute; z-index: 2; width: 34px; height: 34px; display: flex; align-items: center; justify-content: center;"><i class="fa fa-search"></i></label>
            <input type="text" style="width: 100%; padding-left: 30px; border-bottom: none; border-radius: 4px 4px 0 0;" id="node-input-entity-input" placeholder="Digite o ID ou Nome da entidade">
        </div>
        <div class="red-ui-editableList" id="node-input-entity-container">
            <p id="node-input-entity-container-zero" style="width: 100%; margin-top: 10px; text-align: center; color: #999; display: none;">Sem entidades no momento</p>
        </div>
        <input type="hidden" id="node-input-entities">
    </div>
    <div class="form-row">
        <div class="red-ui-editableList" id="node-input-property-container">
            <p id="node-input-property-container-zero" style="width: 100%; margin-top: 10px; text-align: center; color: #999; display: none;">Sem propriedades no momento</p>
        </div>
        <input type="hidden" id="node-input-property">
    </div>
</script>

<script type="text/html" data-help-name="andrerodrigue5-threeway">
    <p>
        This node creates a virtual 3-way switch behavior between two or more Home Assistant entities.
        It is especially useful when you want to synchronize the state of multiple entities that represent
        the same physical or logical control, such as two switches controlling the same light, or mirrored behavior
        across different devices.
    </p>
    <p>
        Supported domains include: <code>switch</code>, <code>light</code>, <code>fan</code>, <code>cover</code>, and <code>input_boolean</code>.
        When any of the monitored entities changes state, this node updates the others to match, creating a seamless
        synchronization effect between them.
    </p>

    <h3>Configuration</h3>
    <dl class="message-properties">
        <dt>Name
            <span class="property-type">string</span>
        </dt>
        <dd>Name to identify this node in the flow.</dd>

        <dt>Server
            <span class="property-type">select</span>
        </dt>
        <dd>Select the Home Assistant server to connect to.  
            <strong>IMPORTANT:</strong> The access token must be generated by a dedicated user account for Node-RED.
        </dd>

        <dt>Targets
            <span class="property-type">array[string]</span>
        </dt>
        <dd>
            List of entity IDs to be monitored and synchronized.  
            A minimum of 2 entities is required.

        </dd>

        <dt>Output properties
            <span class="property-type">array[object]</span>
        </dt>
        <dd>
            Optional. List of custom properties to include in the outgoing message.  
            Each property can be assigned a <code>type</code> of <strong>msg</strong>, <strong>flow</strong>, or <strong>global</strong>,
            allowing you to define how and where the data should be stored or routed in the flow.
        </dd>
    </dl>

    <h3>Outputs</h3>
    <dl class="message-properties">
        <dt>payload.entity_list
            <span class="property-type">array[string]</span>
        </dt>
        <dd>Returns an array of the synchronized entity IDs.</dd>

        <dt>payload.*
            <span class="property-type">any</span>
        </dt>
        <dd>Returns the user-defined output properties set in the configuration. Only <code>msg</code> properties will be returned in the output.</dd>
    </dl>

    <h3>References</h3>
    <ul>
        <li>
            <a href="https://andrerodrigues.com/node-rede/threeway" target="_blank">
                Node documentation: Threeway virtual switch
            </a>
        </li>
    </ul>
</script>

<script type="text/javascript">
    serverStartName = sessionEntityListGetId();
    idProp = 0;

    function getCurrentEntityList() {
        const list =  $('#node-input-entity-container li');
        if(list.length === 0) {
            return [];
        }
        const returnItem = [];
        for(const item of list) {
            returnItem.push({
                id: item.getAttribute('data-id'),
                friendly_name: item.getAttribute('data-name')
            });
        }
        return returnItem;
    }

    RED.nodes.registerType('andrerodrigue5-threeway', {
        category: 'home assistant',
        color: '#41bdf5',
        defaults: {
            name: { value: "" },
            server: { value: serverStartName, type: "server", required: true },
            entities: { value: "[]", required: true },
            property: { value: "[]" },
        },
        inputs: 0,
        outputs: 1,
        icon: "threeway.svg",
        label: function() {
            return this.name || "Threeway entities";
        },
        paletteLabel: 'Threeway',
        description: 'Create a virtual 3-way switch behavior between two or more Home Assistant entities.',
        oneditprepare: function() {
            const node = this;
            let entityListInit;
            try {
                entityListInit = JSON.parse(node.entities || "[]");
            } catch (err) {
                entityListInit = [];
            }
            let propertyListInit;
            try {
                propertyListInit = JSON.parse(node.property || "[]");
            } catch (err) {
                propertyListInit = [];
            }

            let availableEntities = [];
            const blockEntityInput = $("#node-input-entity-input");
            const blockEntityContainer = $("#node-input-entity-container");
            const blockEntityContainerZero = $("#node-input-entity-container-zero");
            const blockEntitySpinner = $("#entity-input-spinner");
            const blockEntityError = $("#entity-input-error");
            const blockEntityPlaceholder = $("#entity-list-placeholder");
            const blockPropertyContainer = $("#node-input-property-container");
            const blockPropertyContainerZero = $("#node-input-property-container-zero");

            function fetchEntities(serverId) {
                if (!serverId || serverId === '_ADD_') {
                    availableEntities = [];
                    blockEntityInput.prop('disabled', true).attr('placeholder', 'Selecione um servidor');
                    blockEntitySpinner.hide();
                    blockEntityError.hide();
                    blockEntityPlaceholder.text('Selecione um servidor para carregar entidades').show();
                    removeAllEntity();
                    configureAutocomplete();
                    return;
                } else if(sessionEntityListGetId() === serverId) {
                    availableEntities = sessionEntityListGetList();
                    blockEntityInput.prop('disabled', false).attr('placeholder', 'Digite ID ou Nome da Entidade');
                    blockEntityPlaceholder.hide();
                    clearRemovetedEntity();
                    configureAutocomplete();
                    return;
                }

                blockEntityInput.prop('disabled', true).attr('placeholder', 'Carregando entidades...');
                blockEntitySpinner.show();
                blockEntityError.hide();
                blockEntityPlaceholder.text('Carregando...').show();

                $.getJSON(`ha-entities/${serverId}`)
                    .done(function(data) {
                        availableEntities = data;
                        sessionEntityListSave(serverId, data);
                        blockEntityInput.prop('disabled', false).attr('placeholder', 'Digite ID ou Nome da Entidade');
                        blockEntityPlaceholder.hide();
                        clearRemovetedEntity();
                        configureAutocomplete();
                    })
                    .fail(function(jqXHR, textStatus, errorThrown) {
                        availableEntities = [];
                        blockEntityInput.prop('disabled', true).attr('placeholder', 'Erro ao carregar entidades');
                        blockEntityError.show();
                        blockEntityPlaceholder.text(`Erro: ${jqXHR.responseJSON?.error || errorThrown || 'Falha ao buscar entidades'}`).show();
                        RED.notify(`Erro ao buscar entidades do Home Assistant: ${jqXHR.responseJSON?.error || errorThrown}`, "error");
                        removeAllEntity();
                        configureAutocomplete();
                    })
                    .always(function() {
                        blockEntitySpinner.hide();
                    });
            }

            blockEntityContainer.editableList({
                addItem: function(row, index, data) {
                    const li = row.parent();
                    li.attr({
                        'data-id': data.id,
                        'data-name': data.friendly_name
                    });
                    blockEntityContainerZero.hide();
                    entityHtmlItem(row, data.id, data.friendly_name);
                },
                removeItem: function() {
                    const allItems = blockEntityContainer.editableList('items');
                    if(allItems.length == 1) {
                        blockEntityContainerZero.show();
                        return;
                    }
                    blockEntityContainerZero.hide();
                },
                addButton: false,
                sortable: true,
                removable: true,
                height: 'auto',
                sortHandle: '.red-ui-editableList-item-handle'
            });
            if(entityListInit.length > 0) {
                blockEntityContainer.editableList('addItems', entityListInit);
            } else {
                blockEntityContainerZero.show();
            }

            function clearRemovetedEntity() {
                const currentEntityList = getCurrentEntityList();
                const removedEntities = currentEntityList.filter(
                    entity => !availableEntities.some(avail => avail.id === entity.id)
                );
                if(removedEntities.length === 0) {
                    return;
                }
                for(const item of removedEntities) {
                    const li = $(`li[data-id="${item.id}"]`, blockEntityContainer);
                    if(li.length === 0) {
                        continue;
                    }
                    li.remove();
                }
            }

            function removeAllEntity() {
                blockEntityContainer.editableList('empty');
            }

            function entityHtmlItem(block, id, friendlyName) {
                block.append(`
                    <div>
                        <span style="width: 100%; display: block;">${friendlyName}</span>
                        <span style="width: 100%; display: block; color: #999; font-size: 12px;">${id}</span>
                    </div>
                `);
            }

            blockPropertyContainer.editableList({
                addItem: function(row, index, data) {
                    const type = 'type' in data ? data.type : 'msg';
                    const key = 'key' in data ? data.key : '';
                    const value = 'value' in data ? data.value : '';
                    blockPropertyContainerZero.hide();
                    propertyHtmlItem(row, type, key, value);
                },
                removeItem: function() {
                    const allItems = blockPropertyContainer.editableList('items');
                    if(allItems.length == 1) {
                        blockPropertyContainerZero.show();
                        return;
                    }
                    blockPropertyContainerZero.hide();
                },
                header: $("<div>").append($.parseHTML(`<div style="width:100%;">Output properties</div>`)),
                sortable: true,
                removable: true,
                height: 'auto',
                sortHandle: '.red-ui-editableList-item-handle'
            });

            if (propertyListInit.length > 0) {
                blockPropertyContainer.editableList('addItems', propertyListInit);
            } else {
                blockPropertyContainerZero.show();
            }
            
            function propertyHtmlItem(block, type, key, value) {
                idProp++;
                block.append(`
                    <div>
                        <input class="red-ui-typedInput input-error property_key" type="text" id="node-input-prop-${idProp}-key" style="width: 30%;" value="${key}">
                        <input type="hidden" id="node-input-prop-${idProp}-type" class="property_type" value="${type}">
                        <div style="display:inline-block; padding:0px 6px;">=</div>
                        <input class="red-ui-typedInput property_value" type="text" style="width: calc(70% - 30px);" value="${value}">
                    </div>
                `);

                $(`#node-input-prop-${idProp}-key`).typedInput({
                    type:"msg",
                    types:["msg", "flow", "global"],
                    typeField: `#node-input-prop-${idProp}-type`
                });
            }

            function entityInUse(id) {
                return $(`li[data-id="${id}"]`, blockEntityContainer).length > 0;
            }
            function isEntityAvailable(id) {
                return availableEntities.find(e => e.id === id);
            }

            function addEntity(id, friendlyName) {
                if (!id || entityInUse(id)) {
                    return;
                }

                const entityObj = isEntityAvailable(id);
                if (!entityObj) {
                    RED.notify(`A entidade "${entity}" não existe ou não é válida.`, "error");
                    return;
                }

                blockEntityContainer.editableList('addItem', {
                    id:id,
                    friendly_name: friendlyName
                });

                blockEntityInput.val("");
            }

            let lastFilteredEntities = [];
            function configureAutocomplete() {
                blockEntityInput.autocomplete({
                    source: function(request, response) {
                        const term = request.term.toLowerCase();
                        const currentEntityList = getCurrentEntityList();
                        const filtered = availableEntities.filter(availableEntity => {
                            const notInCurrent = !currentEntityList.some(entity => entity.id === availableEntity.id);

                            const matchesTerm =
                                availableEntity.id.toLowerCase().includes(term) ||
                                (availableEntity.friendly_name && availableEntity.friendly_name.toLowerCase().includes(term));

                            return notInCurrent && matchesTerm;
                        });
                        lastFilteredForAutocomplete = filtered;
                        response(filtered.map(e => ({
                            friendly_name: e.friendly_name,
                            id: e.id
                        })));
                    },
                    minLength: 0,
                    select: function(event, ui) {
                        event.preventDefault();
                        addEntity(ui.item.id, ui.item.friendly_name);
                        $(this).val('');
                    },
                    focus: function(event, ui) {
                        event.preventDefault();
                    }
                }).autocomplete("instance")._renderItem = function(ul, item) {
                    return $("<li>")
                        .append(`
                            <div>
                                <span style="width: 100%; display: block;">${item.friendly_name}</span>
                                <span style="width: 100%; display: block; color: #999; font-size: 12px;">${item.id}</span>
                            </div>
                        `)
                        .appendTo(ul);
                };

                blockEntityInput.off('click').on('click', function() {
                    if(availableEntities.length > 0) {
                        $(this).autocomplete("search", "");
                    }
                });
            }
            configureAutocomplete();

            blockEntityInput.keypress(function(e) {
                if (e.which === 13) {
                    const menu = blockEntityInput.autocomplete("widget");
                    const focusedItem = menu.find(".ui-state-focus");

                    if (focusedItem.length > 0) {
                        return;
                    }
                    e.preventDefault();
                    if (lastFilteredEntities.length === 1) {
                        addEntity(lastFilteredEntities[0].id, lastFilteredEntities[0].friendly_name);
                        blockEntityInput.autocomplete("close");
                    }
                }
            });

            if(serverStartName) {
                availableEntities = [];
                fetchEntities(serverStartName);
            }
            setTimeout(() => {
                $("#node-input-server").on('change', function() {
                    sessionEntityListDelete();
                    const newServerId = $(this).val();
                    availableEntities = [];
                    removeAllEntity();
                    fetchEntities(newServerId);
                });
            }, 1000);
        },
        oneditsave: function() {
            const currentEntityList = getCurrentEntityList();
            if(currentEntityList.length < 2) {
                RED.notify("Você precisa de pelo menos 2 entities para o three way", "error");
            }

            const entityReturn = JSON.stringify(currentEntityList);
            $("#node-input-entities").val(entityReturn);
            this.entities = entityReturn;

            const listPropertyContainer = $("#node-input-property-container li");
            let propertyReturn = [];
            for(item of listPropertyContainer) {
                const key = $('.property_key', item).val();
                const type = $('.property_type', item).val();
                const value = $('.property_value', item).val();
                if(typeof key !== 'string' || key === '') {
                    continue;
                }
                propertyReturn.push({key, type, value});
            }
            propertyReturn = JSON.stringify(propertyReturn);
            $("#node-input-property").val(propertyReturn);
            this.property = propertyReturn;
        }
    });
    
    function sessionEntityListValidationType(entity) {
        try {
            const valor =
                typeof entity === 'object' &&
                'id' in entity &&
                'list' in entity &&
                Array.isArray(entity.list) &&
                entity.list.length > 0;
            return valor;
        } catch (error) {
            console.error('Erro ao validar entityListType', error);
            return false;
        }
    }

    function sessionEntityListGetId() {
        const entityListString = localStorage.getItem('ha_threeway_entity_list');
        if(!entityListString) {
            return '';
        }
        try {
            const entityList = JSON.parse(entityListString);
            if(sessionEntityListValidationType(entityList)) {
                return entityList.id;
            }
            return '';
        } catch (error) {
            console.error('Erro ao analisar a lista de entidades do localStorage:', error);
            return '';
        }
    }

    function sessionEntityListValidation(serverId){
        const entityListString = localStorage.getItem('ha_threeway_entity_list');
        if (entityListString) {
            try {
                const entityList = JSON.parse(entityListString);
                return sessionEntityListValidationType(entityList) && entityList.id === serverId;
            } catch (error) {
                console.error('Erro ao analisar a lista de entidades do localStorage:', error);
                return false;
            }
        }
        return false;
    }

    function sessionEntityListGetList() {
        const entityListString = localStorage.getItem('ha_threeway_entity_list');
        if (entityListString) {
            try {
                const entityList = JSON.parse(entityListString);
                if (sessionEntityListValidationType(entityList)) {
                    return entityList.list;
                }
            } catch (error) {
                console.error('Erro ao analisar a lista de entidades do localStorage:', error);
            }
        }
        return [];
    }

    function sessionEntityListSave(serverId, entityList) {
        try {
            const entityListString = JSON.stringify({
                id: serverId,
                list: entityList
            });
            localStorage.setItem('ha_threeway_entity_list', entityListString);
        } catch (error) {
            console.error('Erro ao salvar a lista de entidades no localStorage:', error);
        }
    }

    function sessionEntityListDelete() {
        localStorage.removeItem('ha_threeway_entity_list');
    }
</script>

